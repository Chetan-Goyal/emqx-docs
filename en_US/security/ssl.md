# SSL(TLS)

When connecting to external resources like a database or some HTTP API, EMQX can establish secure connections
via SSL(TLS).

## TLS authentication

To enable TLS authentication for clients, one may add an `ssl` listener
and set its `ssl.verify` option to `verify_peer`.

The default `ssl` MQTT listener runs on the 8883 port:

```hocon
listeners.ssl.default {
  bind = "0.0.0.0:8883"

  access_rules = [
    "allow all"
  ]

  proxy_protocol = false
  proxy_protocol_timeout = 3s

  ssl.keyfile = "etc/certs/key.pem"
  ssl.certfile = "etc/certs/cert.pem"
  ssl.cacertfile = "etc/certs/cacert.pem"

  # to verify client certs
  ssl.verify = verify_peer

  ssl.versions = ["tlsv1.3", "tlsv1.2", "tlsv1.1", "tlsv1"]
  tcp.backlog = 1024
  tcp.buffer = 4KB
}
```

Note that the `key.pem`,` cert.pem`, and `cacert.pem` under the default directory of `etc/certs` are self-signed certificates generated by EMQX Broker. Therefore, when testing with a client that supports TLS, you need to configure the above CA certificate `etc/certs/cacert.pem` to the client. For production use, securely issued certificates must be used.

## PSK authentication

To enable PSK authentication, one should enable `psk_authentication` section in `emqx.conf`:

```hocon
psk_authentication {
    ## Whether to enable the PSK feature.
    enable = true

    ## If init file is specified, emqx will import PSKs from the file
    ## into the built-in database at startup for use by the runtime.
    ##
    ## The file has to be structured line-by-line, each line must be in
    ## the format: <PSKIdentity>:<SharedSecret>
    init_file = "data/init.psk"

    ## Specifies the separator for PSKIdentity and SharedSecret in the init file.
    ## The default is colon (:)
    separator = ":"

    ## The size of each chunk used to import to the built-in database from psk file
    ## chunk_size = 50
}
```

File with psk identities and keys (`data/init.psk`) should be created:

```
myclient1:8c701116e9127c57a99d5563709af3deaca75563e2c4dd0865701ae839fb6d79
myclient2:d1e617d3b963757bfc21dad3fea169716c3a2f053f23decaea5cdfaabd04bfc4
...
```

`ssl` listener should be configured to use PSK ciphers:

```
listeners.ssl.default {
  ...
  ssl.versions = ["tlsv1.2"]
  ssl.ciphers = "RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,RSA-PSK-RC4-SHA,RSA-PSK-DES-CBC3-SHA"
  ...
}

```

## Client options

SSL configuration options are common for all external resources.

Example SSL configuration:

```
ssl {
    ciphers = [
        "TLS_AES_256_GCM_SHA384",
        "TLS_AES_128_GCM_SHA256",
        "TLS_CHACHA20_POLY1305_SHA256",
        "TLS_AES_128_CCM_SHA256",
        "TLS_AES_128_CCM_8_SHA256"
    ]
    depth = 10
    enable = true
    reuse_sessions = true
    secure_renegotiate = true
    verify = verify_peer
    versions = [
        "tlsv1.3"
    ]
}
```

All SSL parameters are optional. Also, for the resources that support SSL, the very `ssl` configuration section is optional too. Its absence denotes that TLS layer shouldn't be used, i.e. is equivalent to
```
ssl {
    enable = false
}
```

### `enable`

Boolean field indicating whether SSL should be used for the client connection. The default is `false`.

### `verify`

Optional field, one of `verify_peer` or `verify_none`. The default value is `verify_none`. Enable(`verify_peer`) or disable(`verify_none`) peer verification.

### `versions`

Optional list of SSL versions to use. Possible versions are: `tlsv1.3`, `tlsv1.2`, `tlsv1.1`, and `tlsv1`.

### `ciphers`

Optional list of ciphers to use. The default list is:

```
# TLS 1.3:
TLS_AES_256_GCM_SHA384
TLS_AES_128_GCM_SHA256
TLS_CHACHA20_POLY1305_SHA256
TLS_AES_128_CCM_SHA256
TLS_AES_128_CCM_8_SHA256

# TLS 1.2 and below:
ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES256-SHA384
ECDHE-RSA-AES256-SHA384
ECDH-ECDSA-AES256-GCM-SHA384
ECDH-RSA-AES256-GCM-SHA384
ECDH-ECDSA-AES256-SHA384
ECDH-RSA-AES256-SHA384
DHE-DSS-AES256-GCM-SHA384
DHE-DSS-AES256-SHA256
AES256-GCM-SHA384
AES256-SHA256
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES128-SHA256
ECDHE-RSA-AES128-SHA256
ECDH-ECDSA-AES128-GCM-SHA256
ECDH-RSA-AES128-GCM-SHA256
ECDH-ECDSA-AES128-SHA256
ECDH-RSA-AES128-SHA256
DHE-DSS-AES128-GCM-SHA256
DHE-DSS-AES128-SHA256
AES128-GCM-SHA256
AES128-SHA256
ECDHE-ECDSA-AES256-SHA
ECDHE-RSA-AES256-SHA
DHE-DSS-AES256-SHA
ECDH-ECDSA-AES256-SHA
ECDH-RSA-AES256-SHA
ECDHE-ECDSA-AES128-SHA
ECDHE-RSA-AES128-SHA
DHE-DSS-AES128-SHA
ECDH-ECDSA-AES128-SHA
ECDH-RSA-AES128-SHA

# PSK ciphers:
RSA-PSK-AES256-GCM-SHA384
RSA-PSK-AES256-CBC-SHA384
RSA-PSK-AES128-GCM-SHA256
RSA-PSK-AES128-CBC-SHA256
RSA-PSK-AES256-CBC-SHA
RSA-PSK-AES128-CBC-SHA
```

### `cacertfile`, `certfile`, and `keyfile`
String fields with filenames of the corresponding pem-encrypted keys/certificates for establishing connections and verifying peers.

### `reuse_sessions`

Boolean field, specifying whether to reuse SSL sessions. The default is `true`.

### `depth`

Integer field, maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. The default is `10`.

### `password`

String containing the password for a password-protected private keyfile.

### `secure_renegotiate`

Boolean field, the default is `true`.
SSL parameter renegotiation is a feature that allows a client and a server
to renegotiate the parameters of the SSL connection on the fly.
RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
you drop support for the insecure renegotiation, prone to MitM attacks.

### `server_name_indication`

String containing the hostname to be used in TLS Server Name Indication extension.
