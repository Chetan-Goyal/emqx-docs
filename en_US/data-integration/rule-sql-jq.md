# JQ functions

[JQ](https://stedolan.github.io/jq/) is a powerful command line tool and programming language designed primarily for transforming and querying data encoded as [JSON](https://www.json.org/json-en.html).

Typical JQ programs describe simple transformations or filters for JSON data, but one can also use JQ to perform complex computations when needed.

## How It Works

The rule's SQL language integrates JQ through two functions:

| Function | Parameters                                                                                                     | Returned value                                                                                                                                                                                                                                                                |
| -------- | -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `jq`     | 1. string containing valid jq program<br/> 2. JSON encoded string or object <br/>3. Optional, integer timeout value (milliseconds, default is `10 seconds`) | list of objects corresponding to the JSON objects generated by the given JQ program (parameter 1) when given the input provided by parameter 2. The function throws an exception if the execution did not finish before the timeout or if the jq program throws an exception. |

> The default timeout value can be configured via `rule_engine.jq_function_default_timeout`.

The [JQ documentation](https://stedolan.github.io/jq/manual/) is a good
resource for learning how to write JQ programs. You can also
[try out JQ programs in this online environment](https://jqplay.org/), install it on your
computer, or watch [EMQX's JQ introduction video](https://www.youtube.com/watch?v=_GwF8zvhNcQ). JQ is a
[Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) high-level
functional programming language.

The following are some examples of simple `jq` function calls
and their results:

### Example 1

Simple `jq` function calls example:

```SQL
jq('.', '{"temprature": 10}') =
[json_decode('{"temprature": 10}')]

jq('.', json_decode('{"temprature": 10}')) =
[json_decode('{"temprature": 10}')]

jq('.temprature', '{"temprature": 10}') =
[10]

jq('{temprature_C:.temprature,
     temprature_F: (.temprature * 1.8 + 32)}',
   '{"temprature": 10}') =
[json_decode('{"temprature_C": 10, "temprature_F": 50}')]

jq('.temprature,(.temprature * 1.8 + 32)', '{"temprature": 10}') =
[10, 50]
```

### Example 2

The above examples only scratch the surface of what can be done with JQ. The
below example illustrates what a more complex JQ program might look like and
how one can combine the `jq` function with the `FOREACH` statement to divide
JQ's output objects into multiple messages.

```sql
FOREACH   jq('def rem_first:
                 if length > 2 then del(.[0]) else . end;
              def rem_last:
                 if length > 1 then del(.[-1]) else . end;
              .date as $date |
              .sensors[] |
                (.data | sort | rem_first | rem_last | add / length) as $average |
                {$average, $date}',
             payload)
FROM    "jq_demo/complex_rule/jq/#"
```

Below is an example of input payload for the code above:

```json
{
  "date": "2020-04-24",
  "sensors": [
    {
      "name": "a",
      "data": [3, 1, 2, 4, 5, 5]
    },
    {
      "name": "b",
      "data": [1, -100, 2, 3, 4, 5, 2000]
    },
    {
      "name": "c",
      "data": [3, 7, 9]
    }
  ]
}
```

The rule SQL snippet above will create one output message for each
sensor in the input data. Each message will be a JSON object containing
one field for the date and one field for the average of the sensor's data field
after the smallest and largest values have been removed (as they might be
outliers). Thus given the payload above, the three output messages will have
the following payloads:

Message 1:

```json
{
  "average": 3.5,
  "date": "2020-04-24"
}
```

Message 2:

```json
{
  "average": 3,
  "date": "2020-04-24"
}
```

Message 3:

```json
{
  "average": 7,
  "date": "2020-04-24"
}
```

## More Examples

The following example will also split a message into multiple messages. The `FOREACH` uses the JQ function to transform the input message's payload into an array. The `jq` function takes a JQ program as its first argument and the data to be processed by the JQ program as it's second argument. The JQ program in this example will transform the input message's payload into an array of objects with the following fields: `sensor_type`, `value`. The `DO` clause specifies that the `timestamp`, `clientid`, `sensor_type` and `value` fields should be included in the output message's payload. The `FROM` clause specifies that the rule should be applied to messages with a topic matching the [topic filter](https://www.emqx.com/en/blog/advanced-features-of-mqtt-topics) `car/measurements`.

```sql
FOREACH
    ## The data must be an array
    jq('
       [{
         sensor_type: "temprature",
         value: .temprature
        },
        {
         sensor_type: "humidity",
         value: .humidity
        },
        {
         sensor_type: "pressure",
         value: .pressure
        },
        {
         sensor_type: "light",
         value: .light
        },
        {
         sensor_type: "battery",
         value: .battery
        },
        {
         sensor_type: "speed",
         value: .speed
        }]',
        payload) as sensor  
DO
    payload.client_id,
    payload.timestamp,
    sensor.sensor_type,
    sensor.value
FROM "car/measurements"
```

The following example is equivalent to the previous example, but uses a different JQ program and no `DO` clause. This example is meant to illustrate that the JQ programs are very powerful and can be used to do any type of transformation. That being said, one should avoid doing computationally expensive transformations in EMQX rules as this can affect the performance of the EMQX broker. 

```sql
FOREACH
    jq('
       # Save the input
       . as $payload |
       
       # All sensor types
       [ 
         "temperature",
         "humidity",
         "pressure",
         "light",
         "battery",
         "speed" 
       ] as $sensor_types |
       
       # Output an object for each sensor type
       $sensor_types[] |
       {
         client_id: $payload.client_id,
         timestamp: $payload.timestamp,
         sensor_type: .,
         value: $payload[.] 
       }
       ',
       payload) as sensor  
FROM "car/measurements"
```

## Notice

JQ functions can be convenient for transformations that are difficult or impossible to do with only the rule SQL language and its simple functions.

It is not recommended to do long-running computations in the rule as this can significantly slow down the rate at which EMQX can process new messages. The JQ functions have timeouts to prevent possibly buggy JQ programs (that may have gotten stuck in an infinite loop) from taking too much processing time from the rest of the EMQX system.
