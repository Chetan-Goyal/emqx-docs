# 嵌入式数据库

EMQX使用一个嵌入式数据库[Mria](https://github.com/emqx/mria)来存储以下信息。

- 路由表
- 会话
- 配置
- 警报
- 等等

Mria的表会被复制到所有EMQX节点上。
这也有助于容错：只要集群中至少有一个节点是活的，数据就是安全的。

如果EMQX集群的规模低于5个节点，通常不需要对数据库的弹性伸缩能力进行调优。

然而，为了实现横向扩展，建议将集群中的节点分成两个角色。

- 核心（Core）节点 
- 复制（Replicant）节点

## 节点角色

*核心节点*作为数据库的真数据源：它们以全网状连接，每一个节点都包含一个最新的数据副本。
核心节点一般是静态和持久的，也就是说，不建议对核心集群进行自动伸缩。

另一方面，*复制节点*，将所有表的写操作转到核心节点上处理。
它们各自连接到核心节点的其中一个，并被动地复制核心节点的事务。
这意味着复制节点不允许自己执行任何写操作。
相反，它们要求核心节点代表它们更新数据。
同时，它们有一个完整的本地数据副本，所以读取访问的速度也同样快。

这种方法解决了两个问题。

- 横向可扩展性（我们已经测试了有23个节点的EMQX集群）
- 它可以实现复制节点集群的自动伸缩

由于复制节点不参与数据写入，当更多的复制者加入集群时，表的更新效率不会受到影响。
进而允许创建更大的EMQX集群。

另外，复制节点被设计成可以按需增删，
添加或删除它们不会改变数据冗余，所以它们可以被放在一个自动伸缩组中，从而实现更好的DevOps实践。
请注意，根据总数据量的大小，从核心节点初始复制数据是一个相对繁重的操作，所以自动伸缩策略不能过于激进。

## 配置

在EMQX 5.0中，所有节点都默认为核心角色，所以不做任何调整，集群的行为就像4.*。

为了使用新的复制协议，在集群中的一些节点上设置`EMQX_NODE__DB_ROLE`环境变量或`emqx.conf`中的`node.db_role`设置为`replicant`，这样它们将承担复制者角色。请注意，集群中必须至少有一个核心节点，我们建议以3个核心+N个复制者的设置为最初配置。

根据业务需求，核心节点即可以接受MQTT流量，也可以把所有的MQTT监听器关闭，从而变成纯粹的数据库服务器。

- 在一个小集群中（总共3个节点或更少），引入复制节点并不经济，所以可以由核心节点承担所有的流量。
- 在一个非常大的集群中（例如10或更多个节点），核心+复制节点集训的优势可以很好的发挥出来。
- 在一个中等规模的集群中，节点数量的选取取决于诸多因素，所以根据模拟生产环境的场景测试情况进行灵活选择。

## 监控和故障排查

对Mria性能的监控可以通过Prometheus指标或使用Erlang控制台来完成。

### Prometheus 系统指标
#### 核心节点
- `emqx_mria_last_intercepted_trans`：自节点启动以来，分片区收到的事务数量。注意，这个值在不同的核心节点上可能不同。
- `emqx_mria_weight`：一个用于负载平衡的值。它的变化取决于核心节点的瞬间负载。
- `emqx_mria_replicants`：连接到核心节点的复制节点数量。
- `emqx_mria_server_mql`：未处理的事务数量，等待发送至复制者节点。越少越好。如果这个指标有增长的趋势，则可能需要为当前的核心节点增加算力资源，或添加更多的核心节点。

#### 复制者节点
- `emqx_mria_lag`。复制者节点滞后，表示复制者节点滞后上游核心节点的程度。越少越好。
- `emqx_mria_bootstrap_time`：复制者节点启动过程中花费的时间。这个值在复制者节点的正常运行过程中不会改变。
- `emqx_mria_bootstrap_num_keys`：在初始复制过程中从核心节点复制的数据库记录的数量。这个值在复制者节点的正常运行中不会改变。
- `emqx_mria_message_queue_len`：复制进程的消息队列长度。应该一直保持在0左右。
- `emqx_mria_replayq_len`：复制者节点的内部重放队列的长度。越少越好。

### 控制台命令

执行 `emqx_ctl eval 'mria_rlog:status().'` 命令可以获得关于嵌入式数据库状态的更多信息。
