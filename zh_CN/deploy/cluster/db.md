# 嵌入式数据库

EMQX使用一个嵌入式数据库[Mria](https://github.com/emqx/mria)来存储以下信息。

- 路由表
- 会话
- 配置
- 警报
- 等。

Mria的表会被复制到所有EMQX节点上。
这也有助于容错：只要集群中至少有一个节点是活的，数据就是安全的。

如果EMQX集群的规模低于5个节点，通常不需要对嵌入式数据库进行调整。

然而，为了实现横向扩展，建议将集群中的节点分成两类（角色）。

- 核心节点
- 复制者节点

## 节点角色

*核心节点*作为数据库的真数据源：它们以全网状连接，每一个节点都包含一个最新的数据副本。
核心节点一般是静态和持久的，也就是说，不建议对核心集群进行自动伸缩。

另一方面，*复制者节点*，将所有表的写操作转到核心节点上处理。
它们连接到其中一个核心节点，并被动地复制核心节点的事务。
这意味着复制者节点不允许自己执行任何写操作。
相反，它们要求核心节点代表它们更新数据。
同时，他们有一个完整的本地数据副本，所以读取访问的速度也同样快。

这种方法解决了两个问题。

- 横向可扩展性（我们已经测试了有23个节点的EMQX集群）

- 它可以实现复制者节点集群的自动伸缩

由于复制者节点不参与写入，当更多的复制者加入集群时，表的更新效率不会受到影响。
这允许创建更大的EMQX集群。

另外，复制体节点被设计成短暂的。
添加或删除它们不会改变数据冗余，所以它们可以被放在一个自动伸缩组中，从而实现更好的DevOps实践。
请注意，根据数据的大小，从核心节点初始复制数据是一个相对繁重的操作，所以自动伸缩策略不能过于激进。

## 配置

在EMQX 5.0中，所有节点都默认为核心角色，所以不做任何调整，集群的行为就像4.*。

为了使用新的复制协议，在集群中的一些节点上设置`EMQX_NODE__DB_ROLE`环境变量或`emqx.conf`中的`node.db_role`设置为`replicant`，这样它们将承担复制者角色。请注意，集群中必须至少有一个核心节点，我们建议以3个核心+N个复制者的设置为最初配置。

核心节点可以接受MQTT流量，或者它们可以纯粹作为复制者的数据库服务器，这取决于使用情况。

- 在一个小集群中（总共3个节点或更少），使用复制体并不经济，所以核心节点承担所有的流量。
- 在一个非常大的集群中（10个节点或更多），将流量从核心节点移开是有意义的。
- 在一个中等规模的集群中，这真的取决于许多因素，所以需要进行实验。

## 监测和故障排除

对Mria性能的监控可以通过Prometheus指标或使用Erlang控制台来完成。

### Prometheus 系统指标
#### 核心节点
- `emqx_mria_last_intercepted_trans`: 自节点启动以来，分片区收到的事务数量。注意，这个值在不同的核心节点上可能不同。
- `emqx_mria_weight`: 一个用于负载平衡的值。它的变化取决于核心节点的瞬间负载。
- `emqx_mria_replicants`: 连接到核心节点的复制者节点的数量，复制给定分片的数据。
- `emqx_mria_server_mql`: 未处理的事务数量，等待发送至复制者节点。越少越好。如果这个指标有增长的趋势，需要更多的核心节点。

#### 复制者节点
- `emqx_mria_lag`。复制者节点滞后，表示复制者节点滞后上游核心节点的程度。越少越好。
- `emqx_mria_bootstrap_time`: 复制者节点启动过程中花费的时间。这个值在复制者节点的正常运行过程中不会改变。
- `emqx_mria_bootstrap_num_keys`: 在引导过程中从核心节点复制的数据库记录的数量。这个值在复制者节点的正常运行中不会改变。
- `emqx_mria_message_queue_len`: 复制进程的消息队列长度。应该一直保持在0左右。
- `emqx_mria_replayq_len`: 复制者节点的内部重放队列的长度。越少越好。

### 控制台命令

`mria_rlog:status().`此命令可以在EMQX erlang shell中执行，以获得关于嵌入式数据库状态的更多信息。
